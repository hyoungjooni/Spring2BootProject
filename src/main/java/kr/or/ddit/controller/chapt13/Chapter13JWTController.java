package kr.or.ddit.controller.chapt13;

public class Chapter13JWTController {

	
	/*
	 * [ 13장. JWT ]
	 * 
	 * 1. 토큰 기반 인증
	 * 
	 *       # 토큰 기반 인증이란?
	 * 
	 *       사용자가 서버에 접근할 때 사용자가 인증된 사용자인지 확인하는 방법은 다양합니다.
	 *       대표적인 사용자 인증 확인 방법으로 서버 기반 인증과 토큰 기반 인증이 있습니다.
	 *       스프링 시큐리티에서는 기본적으로 세션 기반 인증을 제공합니다. 기본적으로 제공해주는 세션 기반 인증을 사용해 사용자마다 사용자의 정보를
	 *       담은 세션을 생성하고 저장해서 인증을 합니다. 이를 세션 기반 인증이라고 합니다.
	 *       토큰 기반 인증은 토큰을 사용하는 방법입니다. 토큰은 서버에서 클라이언트를 구분하기 위한 유일한 값인데 서버가 토큰을 생성해서 클라이언트에게
	 *       제공하면, 클라이언트는 이 토큰을 갖고 있다가 여러 요청을 이 토큰과 함께 신청합니다. 그럼 서버는 토큰만 보고 유일한 사용자인지 검증합니다.
	 * 
	 *       # 토큰을 전달하고 인증받는 과정 (process)
	 * 
	 *                [클라이언트]                     		[  서버  ]
	 *                   │                                   │
	 *                   │        1. 로그인 요청    	         │
	 *                   ├────────────────────────────────>──┤
	 *                 	 │        2. 토큰 생성 후 응답        	 │
	 *    3. 토큰 저장		 ├────<──────────────────────────────┤
	 *                   │        4. 토큰 정보와 함께 요청     	 │
	 *                   ├────────────────────────────────>──┤
	 *                   │        6. 응답              		 │   5. 토큰 검증
	 *                   ├────<──────────────────────────────┤
	 * 
	 *          1. 클라이언트가 아이디와 비밀번호를 서버에게 전달하면서 인증을 요청하면
	 *          2. 서버는 아이디와 비밀번호를 확인해 유효한 사용자인지 검증합니다. 유효한 사용자면 토큰을 생성해서 응답합니다.
	 *          3. 클라이언트는 서버에서 준 토큰을 저장합니다.
	 *          4. 이후 인증이 필요한 API를 사용할 때 토큰을 함께 보냅니다.
	 *          5. 그러면 서버는 토큰이 유효한지 검증합니다.
	 *          6. 토큰이 유효하다면 클라이언트가 요청한 내용을 처리합니다.
	 * 
	 *         # 토큰 기반 인증의 특징
	 * 
	 *       1) 무상태성
	 * 
	 *       무상태성은 사용자의 인증 정보가 담겨있는 토큰이 서버가 아닌 클라이언트에 있으므로 서버에 저장할 필요가 없습니다.
	 *       서버가 뭔가 데이터를 유지하고 있으려면 그만큼 자원을 소비해야 합니다. 그런데 토큰 기반 인증에서는 서버에서 인증 정보가 담긴 토큰을 생성하고
	 *       인증합니다. 따라서 클라이언트에서는 사용자의 인증 상태를 유지하면서 이후 요청을 처리해야 하는데 이것을 '상태를 관리'한다고 합니다.
	 *       이렇게 하면 서버 입장에서는 클라이언트의 인증 정보를 저장하거나 유지하지 않아도 되기 때문에 완정한 무상태(stateless)로 효율적인 검증을
	 *       할 수 있습니다.
	 * 
	 *       2) 확장성
	 *    
	 *       무상태성은 확장성에 영향을 줍니다. 서버를 확장할 때 상태 관리를 신경 쓸 필요가 없으니 서버 확장에도 용이한 것이죠. 예를 들어, 물건을 파는
	 *       서비스가 있고 결제를 위한 서버와 주문을 위한 서버가 분리되어 있다고 가정합니다. 세션 인증 기반은 각각 API에서 인증을 해야 되는 것과는 달리
	 *       토큰 기반 인증에서는 토큰을 가지는 주체는 서버가 아니라 클라이언트이기 때문에 가지고 있는 하나의 토큰으로 결제 서버와 주문 서버에게 요청을
	 *       보낼 수 있습니다. 추가로 페이스북 로그인, 구글 로그인 같이 토큰 기반 인증을 사용하는 다른 시스템에 접근해 로그인 방식을 확장할 수도 있고,
	 *       이를 활용해 다른 서비스에 권한을 공유할 수도 있습니다.
	 * 
	 *       3) 무결성 
	 * 
	 *       토큰 방식인 HMAC(Hash-based message authentication) 기법이라고도 부릅니다. 토큰을 발급한 이휴에는 토큰 정보를 변경하는데 행위를
	 *       할 수 없습니다. 즉, 토큰의 무결성이 보장됩니다. 만약 누군가 토큰을 한글자라도 변경하면 서버에서는 유효하지 않는 토큰이라고 판단하는 것입니다.
	 * 
	 * 2. JWT
	 * 
	 *       발급 받은 JWT를 이용해 인증을 하려면 HTTP 요청 헤더 중, Authorization 키 값에 'Bearer ' + JWT 토큰 값을 넣어 보내야 합니다.
	 *       
	 *       Request Headers
	 *       - Accept : *  /  *
	 *       - Accept-Encoding : gzip, deflate, br
	 *       - Accept-Language : ko, en;q=0.9; en-US;q=0.8
	 *       - Authorization : Bearer ejklsfj;lrkgjerohg;oawg...
	 *       - Connection : keep-alive
	 *       - ...
	 * 
	 *    # JWT 구조
	 * 
	 *    xxxxxxxxxxxxxxxxx . xxxxxxxxxxxxxxxxxx . xxxxxxxxxxxxxxxxxxxxxxxxxxx
	 *     헤더(header)          내용(payload)         서명(signature)
	 * 
	 *    1) 헤더(header)
	 *    - 헤더에는 토큰의 타입과 해싱 알고리즘을 지정하는 정보를 담습니다.
	 *       
	 *     ───────────────────────────────────────────────
	 *       이름    |    설명
	 *   ───────────────────────────────────────────────
	 *   typ      | 토큰의 타입을 지정합니다. JWT라는 문자열이 들어가게 됩니다.
	 *   alg      | 해싱 알고리즘을 지정합니다. 
	 *   ───────────────────────────────────────────────
	 *   
	 *   2) 내용(payload)
	 *   - 내용에는 토큰과 관련된 정보를 담습니다. 내용의 한 덩어리를 클레임(claim)이라고 부르며, 클레임은 키 값의 한 쌍으로 이루어져 있습니다.
	 *   - 클레임은 등록된 클레임, 공개 클레임, 비공개 클레임으로 나눌 수 있습니다.
	 *     > 등록된 클레임(registered claim)은 토큰에 대한 정보를 담는데 사용합니다.
	 *     > 공개 클레임(public claim)은 공개용 클레임을 의미합니다.
	 *        충돌을 방지할 수 있는 이름을 가져서야 하며, 보통 클레임 이름을 URI로 지정합니다.
	 *     > 비공개 클레임(private claim)은 사용자 정의 클레임을 의미합니다.
	 *        클레임 간에 사전 간의 충돌이 나지 않도록 해야 합니다.
	 *   
	 *   이름    	  | 설명
	 *   -------- | ----------------------------------------------------------
	 *   iss      | 토큰 발급자(issuer)
	 *   sub      | 토큰 제목(subject)
	 *   aud      | 토큰 대상자(audience)
	 *   exp      | 토큰 만료 시간(expiration), 시간은 NumericDate 형식으로 하며(예: 148084914737), 항상 현재 시간
	 *            | 이후로 설정합니다.
	 *   nbf      | 토큰의 생성 날짜와 비슷한 개념으로 nbf는 Not Before를 의미합니다. NumericDate 형식으로 날짜를 지정하며, 
	 *            | 해당 날짜가 되기 전까지는 토큰이 처리되지 않습니다.
	 *   iat      | 토큰이 발급된 시간으로 iat은 issued at을 의미합니다.
	 *   jti      | JWT의 고유 식별자로서 주로 일회용 토큰에 사용합니다.
	 *  --------  | ----------------------------------------------------------
	 * 
	 * 3) 서명(signature)
	 * - 서명은 해당 토큰이 조작되었거나 변경되지 않았음을 확인하는 용도로 사용하며, 헤더와 인코딩 값과 내용
	 * 
	 * 3. JWT 서비스 구현하기
	 * 
	 *      1) JWT 서비스 설정
	 *      
	 *         # JWT 의존 라이브러리 설정
	 *         - pom.xml 내, jwt 의존 라이브러리 추가
	 *         > jjwt, jjwt-api, jaxb-api, configuration-processor
	 *      
	 *         # 토큰 제공자 추가하기
	 *         - application.properties 내, issuer와 secret_key 추가
	 *         
	 *         # 프로퍼티값 매핑 클래스 설정
	 *         - jwt 패키지 내, JwtProperties 클래스 생성
	 *      
	 *      2) JWT 서비스 구현
	 *
	 *         # JWT 토큰 생성 및 토큰 해석
	 *         - JWT 컨트롤러 만들기 (JwtLoginController)
	 *         - JWT 토큰 생성 컨트롤러 메서드 만들기 (login:post)
	 *         - Talend API Tester로 확인
	 *         
	 *         - JWT 토큰 해석 컨트롤러 메소드 만들기 (userInfo:get)
	 *         - Talend API Tester로 확인
	 *
	 *         *** JWT Token 확인해보기
	 *         - https://jwt.io/ 사이트에서 encoded 항목에 login 요청 시, 발급받은 jwt 토큰을 복사해서 넣는다.
	 *         - header, payload, signature 정보를 확인한다.
	 *            > 이때, secret_key를 설정하지 않았으므로 'invalid signature'라고 표시된다. (검증되지 않은 토큰)   
	 *            > 토큰 생성 시, 작성했던 secret_key를 함께 작성 후 진행한다.
	 */
	
}
